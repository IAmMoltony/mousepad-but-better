/*
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <mousepad/mousepad-private.h>
#include <mousepad/mousepad-dbus.h>
/* include the dbus glue generated by gdbus-codegen */
#include <mousepad/mousepad-dbus-infos.h>
#include <mousepad/mousepad-application.h>

#include <dbus/dbus.h>
#include <gio/gio.h>

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif



#define MOUSEPAD_DBUS_PATH      "/org/xfce/Mousepad"
#define MOUSEPAD_DBUS_INTERFACE "org.xfce.Mousepad"



static gboolean  mousepad_dbus_service_launch_files  (MousepadDBusService    *dbus_service,
                                                      GDBusMethodInvocation  *invocation,
                                                      const gchar            *working_directory,
                                                      gchar                 **filenames,
                                                      gpointer                user_data);
static gboolean  mousepad_dbus_service_terminate     (MousepadDBusService   *dbus_service,
                                                      GDBusMethodInvocation *invocation,
                                                      gpointer               user_data);



static void
on_name_acquired (GDBusConnection *connection,
                  const gchar *name,
                  gpointer user_data)
{
  MousepadDBusService *skeleton;

  skeleton = mousepad_dbus_service_skeleton_new ();
  g_signal_connect (skeleton,
                    "handle-launch-files",
                    G_CALLBACK (mousepad_dbus_service_launch_files),
                    NULL);
  g_signal_connect (skeleton,
                    "handle-terminate",
                    G_CALLBACK (mousepad_dbus_service_terminate),
                    NULL);
  g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (skeleton),
                                    connection,
                                    MOUSEPAD_DBUS_PATH,
                                    NULL);
}



void
mousepad_dbus_service_init (void)
{
  g_bus_own_name (G_BUS_TYPE_SESSION,
                  MOUSEPAD_DBUS_INTERFACE,
                  G_BUS_NAME_OWNER_FLAGS_REPLACE,
                  NULL,
                  on_name_acquired,
                  NULL,
                  NULL,
                  NULL);
}



/**
 * mousepad_dbus_service_launch_files:
 * @dbus_service      : A #MousepadDBusService.
 * @invocation        : A #GDBusMethodInvocation
 * @working_directory : The default working directory for this window.
 * @filenames         : A list of filenames we try to open in tabs. The file names
 *                      can either be absolute paths, supported URIs or relative file
 *                      names to @working_directory or %NULL for an untitled document.
 * @user_data         : User data, not used atm.
 *
 * This function is activated by DBus (service) and opens a new window in this instance of
 * Mousepad.
 *
 * Return value: %TRUE on success, %FALSE if @error is set.
 **/
static gboolean
mousepad_dbus_service_launch_files (MousepadDBusService    *dbus_service,
                                    GDBusMethodInvocation  *invocation,
                                    const gchar            *working_directory,
                                    gchar                 **filenames,
                                    gpointer                user_data)
{
  MousepadApplication *application;

  if (!g_path_is_absolute (working_directory))
    {
      g_dbus_method_invocation_return_error_literal (invocation,
                                                     G_DBUS_ERROR,
                                                     G_DBUS_ERROR_INVALID_ARGS,
                                                     "Argument working_directory must be an absolute path");
      return FALSE;
    }

  /* open a mousepad window */
  application = mousepad_application_get ();
  mousepad_application_new_window_with_files (application, NULL, working_directory, filenames);
  g_object_unref (G_OBJECT (application));

  mousepad_dbus_service_complete_launch_files (dbus_service, invocation);

  return TRUE;
}



/**
 * mousepad_dbus_service_terminate:
 * @dbus_service : A #MousepadDBusService.
 * @invocation   : A #GDBusMethodInvocation
 * @error        : User data, not used atm.
 *
 * This function quits this instance of Mousepad.
 *
 * Return value: %TRUE on success.
 **/
static gboolean
mousepad_dbus_service_terminate (MousepadDBusService   *dbus_service,
                                 GDBusMethodInvocation *invocation,
                                 gpointer               user_data)
{
  /* leave the Gtk main loop as soon as possible */
  gtk_main_quit ();

  mousepad_dbus_service_complete_terminate (dbus_service, invocation);

  /* we cannot fail */
  return TRUE;
}



/**
 * mousepad_dbus_client_send:
 * @message : A #DBusMessage.
 * @error   : Return location for errors or %NULL.
 *
 * This function sends the DBus message and should avoid
 * code duplication in the functions below.
 *
 * Return value: %TRUE on succeed or %FALSE if @error is set.
 **/
static gboolean
mousepad_dbus_client_send (DBusMessage  *message,
                           GError      **error)
{
  DBusConnection *connection;
  DBusMessage    *result;
  DBusError       derror;

  dbus_error_init (&derror);

  /* try to connect to the session bus */
  connection = dbus_bus_get (DBUS_BUS_SESSION, &derror);
  if (G_UNLIKELY (connection == NULL))
    {
      g_dbus_error_set_dbus_error (error, derror.name, derror.message, NULL);
      dbus_error_free (&derror);
      return FALSE;
    }

  /* send the message */
  result = dbus_connection_send_with_reply_and_block (connection, message, -1, &derror);

  /* check if no reply was received */
  if (result == NULL)
    {
      /* check if there was just no instance running */
      if (!dbus_error_has_name (&derror, DBUS_ERROR_NAME_HAS_NO_OWNER))
        g_dbus_error_set_dbus_error (error, derror.name, derror.message, NULL);

      dbus_error_free (&derror);
      return FALSE;
    }

  /* but maybe we received an error */
  if (G_UNLIKELY (dbus_message_get_type (result) == DBUS_MESSAGE_TYPE_ERROR))
    {
      dbus_set_error_from_message (&derror, result);
      g_dbus_error_set_dbus_error (error, derror.name, derror.message, NULL);
      dbus_message_unref (result);
      dbus_error_free (&derror);
      return FALSE;
    }

  /* it seems everything worked */
  dbus_message_unref (result);

  return TRUE;
}



/**
 * mousepad_dbus_client_terminate:
 * @error : Return location for errors or %NULL.
 *
 * Function called from this instance of the application and tries to invoke
 * with an already running instance and ties to quit it.
 * The mousepad_dbus_service_terminate function is activated in the running instance.
 *
 * Return value: %TRUE on success.
 **/
gboolean
mousepad_dbus_client_terminate (GError **error)
{
  DBusMessage *message;

  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);

  /* generate the message */
  message = dbus_message_new_method_call (MOUSEPAD_DBUS_INTERFACE, MOUSEPAD_DBUS_PATH,
                                          MOUSEPAD_DBUS_INTERFACE, "Terminate");
  dbus_message_set_auto_start (message, FALSE);


  /* send the message */
  mousepad_dbus_client_send (message, error);

  /* unref the message */
  dbus_message_unref (message);

  /* we return false if an error was set */
  return (error != NULL);
}



/**
 * mousepad_dbus_client_launch_files:
 * @filenames         : A list of filenames we try to open in tabs. The file names
 *                      can either be absolute paths, supported URIs or relative file
 *                      names to @working_directory or %NULL for an untitled document.
 * @working_directory : Working directory for the new Mousepad window.
 * @error             : Return location for errors or %NULL.
 *
 * This function is called within this instance and tries to connect a running instance
 * of Mousepad via DBus. The function mousepad_dbus_service_launch_files is activated in the
 * running instance.
 *
 * Return value: %TRUE on success.
 **/
gboolean
mousepad_dbus_client_launch_files (gchar       **filenames,
                                   const gchar  *working_directory,
                                   GError      **error)
{
  DBusMessage *message;
  guint        length = 0;
  gboolean     succeed;
  GPtrArray   *utf8_filenames;
  gchar       *utf8_dir = NULL;

  g_return_val_if_fail (g_path_is_absolute (working_directory), FALSE);
  g_return_val_if_fail (error == NULL || *error == NULL, FALSE);

  utf8_filenames = g_ptr_array_new_with_free_func(g_free);
  if (filenames != NULL)
    {
      guint i;
      /* get the length of the filesname string */
      length = g_strv_length (filenames);
      g_ptr_array_set_size(utf8_filenames, length + 1);
      /* encode locale filenames to UTF-8 for DBus */
      for (i = 0; i < length; i++)
        {
          gchar *utf8_fn = g_filename_to_utf8(filenames[i], -1, NULL, NULL, error);
          if (utf8_fn == NULL)
            {
              g_ptr_array_free(utf8_filenames, TRUE);
              return FALSE;
            }
          utf8_filenames->pdata[i] = utf8_fn;
        }
    }
  g_ptr_array_add(utf8_filenames, NULL);

  if (working_directory != NULL)
    {
      /* encode working directory to UTF-8 for DBus */
      utf8_dir = g_filename_to_utf8(working_directory, -1, NULL, NULL, error);
      if (utf8_dir == NULL)
        {
          g_ptr_array_free(utf8_filenames, TRUE);
          return FALSE;
        }
    }

  /* generate the message */
  message = dbus_message_new_method_call (MOUSEPAD_DBUS_INTERFACE, MOUSEPAD_DBUS_PATH,
                                          MOUSEPAD_DBUS_INTERFACE, "LaunchFiles");
  dbus_message_set_auto_start (message, FALSE);
  dbus_message_append_args (message,
                            DBUS_TYPE_STRING, &utf8_dir,
                            DBUS_TYPE_ARRAY, DBUS_TYPE_STRING, &utf8_filenames->pdata, length,
                            DBUS_TYPE_INVALID);

  /* send the message */
  succeed = mousepad_dbus_client_send (message, error);

  /* unref the message */
  dbus_message_unref (message);

  /* cleanup the UTF-8 strings */
  g_ptr_array_free(utf8_filenames, TRUE);
  g_free(utf8_dir);

  return succeed;
}
